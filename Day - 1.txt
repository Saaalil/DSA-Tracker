/*
📌 **Question:**
**217. Contains Duplicate**

**Difficulty:** 🟢 Easy

**Description:**
Given an integer array `nums`, return `true` if any value appears at least twice in the array, 
and return `false` if every element is distinct.

---

**Example 1:**
Input: nums = [1,2,3,1]  
Output: true  
Explanation: The element 1 occurs at the indices 0 and 3.

**Example 2:**
Input: nums = [1,2,3,4]  
Output: false  
Explanation: All elements are distinct.

**Example 3:**
Input: nums = [1,1,1,3,3,4,3,2,4,2]  
Output: true

---

**Constraints:**
- 1 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9
*/

/*
💡 **Solution:**
### Approaches:
1️⃣ **Brute Force:**  
   - Compare each element with every other element.  
   - **Time Complexity:** O(n²)  

2️⃣ **HashSet:**  
   - Use a HashSet to track seen elements.  
   - **Time Complexity:** O(n)  
   - ⚠️ Note: This approach may fail certain test cases due to incorrect implementation.  

3️⃣ **Sorting:**  
   - Sort the array and compare adjacent elements.  
   - **Time Complexity:** O(n log n)  
   - ✅ This approach works for all test cases.
*/

// 🛠️ **Java Code Implementation:**
class Solution {
    public boolean containsDuplicate(int[] nums) {
        // 🚧 Brute Force (Commented Out)
        // for (int i = 0; i < nums.length; i++) {
        //     for (int j = i + 1; j < nums.length; j++) {
        //         if (nums[i] == nums[j]) {
        //             return true;
        //         }
        //     }
        // }
        // return false;

        // 🚧 HashSet Approach (Commented Out)
        // Set<Integer> seen = new HashSet<>();
        // for (int num : nums) {
        //     if (seen.contains(num)) {
        //         return true;
        //     }
        //     seen.add(num);
        // }
        // return false;

        // ✅ Sorting Approach
        Arrays.sort(nums); // Sort the array
        int n = nums.length;
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) { // Compare adjacent elements
                return true;
            }
        }
        return false; // No duplicates found
    }
}

---

/*
📌 **Question:**
**242. Valid Anagram**

**Difficulty:** 🟢 Easy

**Description:**
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

---

**Example 1:**
Input: s = "anagram", t = "nagaram"  
Output: true  

**Example 2:**
Input: s = "rat", t = "car"  
Output: false  

---

**Constraints:**
- 1 <= s.length, t.length <= 5 * 10⁴
- `s` and `t` consist of lowercase English letters.
*/

/*
💡 **Solution:**
### Approaches:
1️⃣ **Sorting:**  
   - Convert both strings into arrays, sort them, and compare.  
   - If lengths are equal, return `true`; otherwise, return `false`.  

2️⃣ **HashMap:**  
   - Add the occurrence of each letter into a HashMap.  
   - Compare the maps; if they are equal, the strings are anagrams.
*/

// 🛠️ **Java Code Implementation:**
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        HashMap<Character, Integer> countS = new HashMap<>();
        HashMap<Character, Integer> countT = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            countS.put(s.charAt(i), countS.getOrDefault(s.charAt(i), 0) + 1);
            countT.put(t.charAt(i), countT.getOrDefault(t.charAt(i), 0) + 1);
        }
        return countS.equals(countT);
    }
}

---

/*
📌 **Question:**
**1. Two Sum**

**Difficulty:** 🟢 Easy

**Description:**
Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`.

---

**Example 1:**
Input: nums = [2,7,11,15], target = 9  
Output: [0,1]  
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

**Example 2:**
Input: nums = [3,2,4], target = 6  
Output: [1,2]  

**Example 3:**
Input: nums = [3,3], target = 6  
Output: [0,1]  

---

**Constraints:**
- 2 <= nums.length <= 10⁴
- -10⁹ <= nums[i] <= 10⁹
- -10⁹ <= target <= 10⁹
- Only one valid answer exists.
*/

/*
💡 **Solution:**
### Approach:
1️⃣ **Brute Force:**  
   - Compare every pair of elements.  
   - Return the indices of the pair that adds up to the target.  
   - **Time Complexity:** O(n²)
*/

// 🛠️ **Java Code Implementation:**
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length; // Fix: Use length instead of size()

        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j}; // Fix: Use proper array syntax
                }
            }
        }

        return new int[]{}; // Fix: Return an empty array instead of {}
    }
}